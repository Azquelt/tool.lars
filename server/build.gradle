/*******************************************************************************
* Copyright (c) 2015 IBM Corp.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

apply plugin: 'war'
apply plugin: 'eclipse-wtp'
apply plugin: 'distribution'

import org.apache.tools.ant.filters.*
import org.apache.tools.ant.taskdefs.condition.Os

import static org.apache.tools.ant.taskdefs.condition.Os.*
import static java.lang.ProcessBuilder.Redirect.INHERIT

archivesBaseName = 'larsServer'

ext {
    serverName = archivesBaseName
    testServerName = 'testServer'
}

configurations {
    sharedLibs
    providedCompile.extendsFrom sharedLibs
    antTasks
}

dependencies {
    compile group:'com.fasterxml.jackson.core', name:'jackson-core', version:jackson_version
    compile group:'com.fasterxml.jackson.core', name:'jackson-databind', version:jackson_version
    compile group:'com.fasterxml.jackson.core', name:'jackson-annotations', version:jackson_version
    
    sharedLibs group:'org.mongodb', name:'mongo-java-driver', version:mongodb_java_version
    providedCompile fileTree(dir: "${libertyRoot}/dev/api", include: '**/*.jar')

    testCompile group:'junit', name:'junit', version:junit_version
    testCompile group:'org.hamcrest', name:'hamcrest-library', version:hamcrest_version
    testCompile group:'org.apache.httpcomponents', name:'httpclient', version:httpclient_version
    testCompile group:'org.apache.httpcomponents', name:'httpmime', version:httpmime_version
    testCompile group:'org.jmockit', name:'jmockit', version:jmockit_version
    testCompile project(':test-utils')
    
    // The unit tests need some Liberty classes at runtime, but they should
    // not be compiling against these.
    testRuntime fileTree(dir: "${libertyRoot}/lib", include: '*slf4*.jar')
    
    antTasks group:'net.wasdev.wlp.ant', name:'wlp-anttasks', version:wlp_ant_tasks_version
}

clean {
    dependsOn 'initAnt'
    
    doFirst {
        // Clean will delete the server configuration
        // so make sure we stop it first
        [serverName,testServerName].each{ theServerName ->
            if (isServerRunning(theServerName)) {
                println("Stopping liberty server " + theServerName);
                ant.server(operation: 'stop',
                           installDir: libertyRoot,
                           userDir: 'build/usr',
                           serverName: theServerName)
            }
        }
        
        // Also stop mongod
        if (isMongodRunning()) {
            println("Stopping mongod")
            stopMongod()
        }
    }
}

test {
    dependsOn 'startTestMongod'
    finalizedBy 'stopTestMongod'
    File jmockitJar = configurations.testCompile.find({it.name.startsWith("jmockit")})
    jvmArgs "-javaagent:"+jmockitJar.getAbsolutePath()
}

task initAnt << {
    // Load the Liberty ant tasks
    ant.taskdef(resource: "net/wasdev/wlp/ant/antlib.xml",
                classpath: configurations.antTasks.asPath)
}

// Collects all the files that go into the /usr directory in the right structure
CopySpec usrDirSpec(String serverName) {
    return copySpec {
        from(configurations.sharedLibs) {
            into 'shared/resources/libs'
        }
        
        into("servers/${serverName}") {
            from(war) {
                into 'apps'
            }
            from 'config/server.xml'
        }
    }
}

distributions {
    main {
        baseName = archivesBaseName
        contents {
            into '/usr'
            with usrDirSpec(serverName)
        }
    }
}

task createTestUsrDir (type: Copy) {
    description 'Create the /usr directory for a test server'
    // This is the same as the /usr directory for a production server but uses the testConfig.xml
    
    into 'build/usr'
    with usrDirSpec(testServerName)
    
    rename 'server\\.xml', 'mainServer.xml'
    
    from('config/testServer.xml') {
        into "servers/${testServerName}"
        rename 'testServer\\.xml', 'server.xml'
        filter(ReplaceTokens, tokens:['HTTP_PORT':testLibertyPort,
                                      'TEST_DB_NAME':testDbName,
                                      'MONGO_PORT':testMongoPort,
                                      'LIBERTY_TRACE_SPEC':libertyTraceSpec])
    }
}

task startTestServer {
    description 'Start the server with a test config'
    dependsOn initAnt
    dependsOn createTestUsrDir
    
    onlyIf {!isServerRunning(testServerName)}
    
    doLast {
        ant.server(operation: 'start',
                   installDir: libertyRoot,
                   userDir: 'build/usr',
                   serverName: testServerName)
    }
}

task stopTestServer {
    description 'Shutdown the test server'
    dependsOn initAnt
    mustRunAfter startTestServer
    
    onlyIf { !startTestServer.state.skipped && isServerRunning(testServerName) }

    doLast {
        ant.server(operation: 'stop',
                   installDir: libertyRoot,
                   userDir: 'build/usr',
                   serverName: testServerName)
    }
}

boolean isServerRunning(String theServerName) {
    if (file("build/usr/servers/${theServerName}").exists()) {
        ant.server(operation: 'status',
                   installDir: libertyRoot,
                   userDir: 'build/usr',
                   serverName: theServerName,
                   resultProperty: 'serverStatus')
        // Server status returns zero if server is running
        return ant.properties.serverStatus == '0'
    } else {
        // Server directory does not exist, we cannot query
        // the server state and it should not be running
        return false;
    }
}

task startTestMongod {

    onlyIf { !isMongodRunning() }
    
    doLast {
        delete("build/mongo");
        mkdir("build/mongo/data");
        
        startMongod()
    }
}

task stopTestMongod {

    mustRunAfter startTestMongod

    onlyIf { !startTestMongod.state.skipped && isMongodRunning() }
    
    doLast {
        stopMongod()
    }
}


// Use liberty's 'package' command to produce an artifact that can be installed with
// the 'installUtility' command. The testServer can't just be packaged up as it is 
// using the wrong server.xml, and the name is wrong. 
task packageLars {
    
    description 'Package up LARS in a format that can be installed into a Liberty server using the server\'s installUtility command';
    
    dependsOn 'initAnt'
    dependsOn 'createPackageUsrDir'
    
    def packageJarFile = 'build/' + archivesBaseName + 'Package.jar'
    
    outputs.file packageJarFile

    doLast {
        
        // The 'package' command doesn't produce a jar
        // which is suitable to be installed as a 'sample' using the
        // server's installUtility (that is not the intention of the package command).
        // To make it  work, create the jar and then tweak a few fields in the manifest.
        ant.server(operation: 'package',
                   installDir: libertyRoot,
                   userDir: 'build/usr',
                   serverName: serverName,
                   include: 'usr',
                   archive: packageJarFile)

        // Get all the liberty features that LARS depends on
        def requireFeatureValue = getRequireFeatureValue(file('config/server.xml'))
                
        ant.jar(destfile: packageJarFile, update: true) {
            fileset(dir: rootProject.getRootDir(), includes: 'LICENSE')
            delegate.manifest {
                attribute(name: 'Provide-Feature', value: '') // The sample doesn't provide anything
                attribute(name: 'Require-Feature', value: requireFeatureValue) // All the  features the sample depends on
                attribute(name: 'Sample-Type', value: 'thirdParty') // Tell install utility this is a 'sample'
                attribute(name: 'Archive-Content-Type', value: 'sample')
                attribute(name: 'Archive-Root', value: 'wlp/usr/') // This needs to be set to ensure that sample is uploaded to the repository correctly 
            }
        }
    }
    
}

// Searches a server.xml file for feature definitions, turns them
// into a single string for sticking in the manifest.
String getRequireFeatureValue(File serverXML) {
    String contents = serverXML.text
    String features = ""
    // The mapping from the short name in the server.xml to the feature's package name
    // isn't well defined. Appending 'com.ibm.websphere.appserver' is correct for all
    // the features currently used, although it is a bit fragile.
    (contents =~ /<feature>([^<]+)</).each() { fullMatch, name -> 
        features += "com.ibm.websphere.appserver." + name + "," 
        }
    return features;     
} 

task createPackageUsrDir (type: Copy) {
    description 'Create the /usr directory for a server to be packaged'    
    into 'build/usr'
    with usrDirSpec(serverName)
}

File getMongodExecutable() {
    File mongod = new File(property('mongodExecutable'))
    if (!mongod.exists()) {
        throw new Exception("Cannot find mongod executable")
    }
    return mongod
}

void startMongod() {
    ProcessBuilder builder = new ProcessBuilder(
        getMongodExecutable().getPath(),
        '--port', testMongoPort,
        '--pidfilepath', file('build/mongo/mongo.pid').getAbsolutePath(),
        '--logpath', file('build/mongo/mongo.log').getAbsolutePath(),
        '--dbpath', file('build/mongo/data').getAbsolutePath(),
        '--bind_ip', 'localhost',
        '--smallfiles'
    )
    builder.inheritIO()
    Process p = builder.start()
    
    println("Waiting for mongo to start accepting connections")
    Long startTime = System.currentTimeMillis();
    while (!isMongodRunning() && System.currentTimeMillis() - startTime < 30000) {
        sleep 1000
    }
    if (!isMongodRunning()) {
        throw new Exception("Mongod still not accepting connections after 30s")
    }
}

void stopMongod() {
    stopProcess(file('build/mongo/mongo.pid').text)
}

void stopProcess(String pid) {
    pid = pid.trim()
    if (Os.isFamily(FAMILY_WINDOWS)) {
        exec {
            commandLine("taskkill", "/F", "/PID", pid)
        }
    } else {
        exec {
            commandLine("kill", pid);
        }
        println("Waiting for mongod to exit")
        Long startTime = System.currentTimeMillis();
        while (isMongodRunning() && System.currentTimeMillis() - startTime < 30000) {
            sleep 1000
        }
        if (isMongodRunning()) {
            println("Mongod still running, sending kill signal")
            exec {
                commandLine("kill", "-9", pid)
            }
        }
    }
}

boolean isMongodRunning() {
    // Checking if the mongo process is running is a bit difficult to do in a cross platform way
    // so we'll just poke the port
    try {
        // Open and then immediately close a socket to the mongo port
        new Socket("localhost", testMongoPort.toInteger()).close()
    } catch (IOException e) {
        // We should get an exception if the port is closed
        return false
    }
    // If we get this far then there is at least something listening on the mongo port
    return true
}

eclipse {
    wtp {
        component {
            contextPath = '/'
        }
    }

    
    classpath {
        file {
            whenMerged { classpath ->
                classpath.entries.findAll{ e -> e.kind == 'src' && e.path.startsWith('src/') && !e.path.startsWith('src/main/') }.each {
                    e -> e.output = 'bin-' + (e.path =~ 'src/(.*)/')[0][1]
                }
            }
        }
    }
    
}


// vim: set si:
